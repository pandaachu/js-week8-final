{"version":3,"sources":["webpack:///./node_modules/gsap/ScrollTrigger.js","webpack:///./node_modules/gsap/utils/strings.js","webpack:///./node_modules/gsap/TextPlugin.js"],"names":["gsap","_coreInitted","_win","_doc","_docEl","_body","_root","_resizeDelay","_raf","_request","_toArray","_clamp","_time2","_syncInterval","_refreshing","_pointerIsDown","_transformProp","_i","_prevWidth","_prevHeight","_autoRefresh","_sort","_limitCallbacks","_creatingMedia","_lastMediaTick","_startup","_proxies","_scrollers","_getTime","Date","now","_time1","_lastScrollTime","_enabled","_passThrough","v","_windowExists","window","_getGSAP","registerPlugin","_isViewport","e","indexOf","_getProxyProp","element","property","_getScrollFunc","_ref","s","sc","i","offset","_vertical","push","value","arguments","length","_getBoundsFunc","_winOffsets","width","innerWidth","height","innerHeight","_getBounds","_getSizeFunc","scroller","isViewport","_ref2","d","d2","a","_getOffsetsFunc","_maxScroll","_ref3","Math","max","_iterateAutoRefresh","func","events","_isString","_isFunction","_isNumber","_isObject","_callIfFunc","_combineFunc","f1","f2","result1","result2","_abs","abs","_scrollLeft","_scrollTop","_left","_top","_right","_bottom","_width","_height","_Right","_Left","_Top","_Bottom","_padding","_margin","_Width","_Height","_px","_horizontal","p","p2","os","os2","scrollTo","pageXOffset","op","pageYOffset","_getComputedStyle","getComputedStyle","_makePositionable","style","position","_setDefaults","obj","defaults","withoutTransforms","tween","to","x","y","xPercent","yPercent","rotation","rotationX","rotationY","scale","skewX","skewY","progress","bounds","getBoundingClientRect","kill","_getSize","_ref4","_getLabels","animation","labels","duration","utils","snap","_multiListener","types","callback","split","forEach","type","_addListener","addEventListener","passive","_removeListener","removeEventListener","_markerDefaults","startColor","endColor","indent","fontSize","fontWeight","_defaults","toggleActions","anticipatePin","_keywords","top","left","center","bottom","right","_offsetToPx","size","eqIndex","relative","charAt","parseFloat","substr","_createMarker","name","container","direction","_ref5","matchWidthEl","createElement","useFixedPosition","isScroller","parent","isStart","color","css","offsetWidth","_isStart","setAttribute","cssText","innerText","insertBefore","children","_offset","_positionMarker","marker","start","flipped","vars","display","side","oppositeSide","_isFlipped","set","_triggers","_ids","_sync","_updateAll","_onScroll","_dispatch","_onResize","restart","_listeners","_emptyArray","_media","_onMediaChange","index","tick","ticker","frame","matches","_revertAll","matchMedia","_revertRecorded","_refreshAll","_softRefresh","ScrollTrigger","map","f","_savedStyles","media","uncache","trigger","scroll","rec","revert","force","skipRevert","refreshInits","sort","refresh","result","render","pause","_lastScroll","_direction","l","time","recordVelocity","update","_propNamesToCopy","_stateProps","concat","_swapPinOut","pin","spacer","state","_setState","parentNode","removeChild","_swapPinIn","cs","spacerState","spacerStyle","pinStyle","overflow","boxSizing","appendChild","_capsExp","t","removeProperty","replace","toLowerCase","_getState","_copyState","override","omitOffsets","_parsePosition","scrollerSize","markerScroller","self","scrollerBounds","borderWidth","scrollerMax","localOffset","globalOffset","offsets","m","round","_prefixExp","_reparent","_stOrig","test","core","getCache","_getTweenCreator","lastScroll1","lastScroll2","getScroll","prop","getTween","initialValue","change1","change2","onComplete","modifiers","ratio","call","register","console","warn","this","init","_proto","prototype","nodeType","tweenTo","pinCache","snapFunc","isReverted","scroll1","scroll2","end","markerStart","markerEnd","markerStartTrigger","markerEndTrigger","markerVars","change","pinOriginalState","pinActiveState","pinState","pinGetter","pinSetter","pinStart","pinChange","spacingStart","markerStartSetter","markerEndSetter","snap1","snap2","scrubTween","scrubSmooth","snapDurClamp","snapDelayedCall","prevProgress","prevScroll","prevAnimProgress","horizontal","_vars","onUpdate","toggleClass","id","onToggle","onRefresh","scrub","pinSpacing","invalidateOnRefresh","onScrubComplete","onSnapComplete","once","pinReparent","isToggle","scrollerCache","pinType","callbacks","onEnter","onLeave","onEnterBack","onLeaveBack","markers","onRefreshInit","getScrollerSize","getScrollerOffsets","tweenScroll","lazy","_initted","immediateRender","scrollTrigger","ease","snapTo","scrollBehavior","min","delayedCall","delay","getVelocity","totalProgress","velocity","naturalEnd","endValue","endScroll","data","isActive","targets","className","force3D","getProperty","quickSetter","r","enabled","prevRefreshing","soft","invalidate","isVertical","curTrigger","curPin","oppositeScroll","otherPinOffset","parsedEnd","parsedEndTrigger","endTrigger","parsedStart","triggerIndex","_pinPush","ceil","splice","_pinOffset","reset","wasActive","toggleState","action","stateChanged","toggled","clipped","el","classList","enable","add","disable","allowAnimation","document","documentElement","body","toArray","clamp","globals","requestAnimationFrame","setTimeout","bodyStyle","border","borderTop","setInterval","checkPrefix","w","h","hidden","config","slice","limitCallbacks","ms","syncInterval","clearInterval","autoRefreshEvents","scrollerProxy","target","unshift","mq","addListener","clearMatchMedia","query","version","saveStyles","create","safe","maxScroll","getScrollFunc","getById","getAll","isScrolling","batch","varsCopy","interval","batchMax","proxyCallback","elements","triggers","b","refreshPriority","_trimExp","emojiExp","getText","textContent","firstChild","nextSibling","nodeValue","splitInnerHTML","delimiter","trim","node","apply","emojiSafeSplit","nodeName","outerHTML","text","j","character","charCodeAt","emoji","_tempDiv","TextPlugin","_short","original","condensedText","condensedOriginal","aggregate","toUpperCase","svg","getBBox","innerHTML","from","_from","hasClass","newClass","oldClass","fillChar","padSpace","speed","maxDuration","_props","applyNew","applyOld","str","join"],"mappings":"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","file":"js/chunk-4ca63b63.45e17376.js","sourcesContent":["/*!\n * ScrollTrigger 3.5.1\n * https://greensock.com\n *\n * @license Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _root,\n    _resizeDelay,\n    _raf,\n    _request,\n    _toArray,\n    _clamp,\n    _time2,\n    _syncInterval,\n    _refreshing,\n    _pointerIsDown,\n    _transformProp,\n    _i,\n    _prevWidth,\n    _prevHeight,\n    _autoRefresh,\n    _sort,\n    _limitCallbacks,\n    // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n_startup = 1,\n    _proxies = [],\n    _scrollers = [],\n    _getTime = Date.now,\n    _time1 = _getTime(),\n    _lastScrollTime = 0,\n    _enabled = 1,\n    _passThrough = function _passThrough(v) {\n  return v;\n},\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isViewport = function _isViewport(e) {\n  return !!~_root.indexOf(e);\n},\n    _getProxyProp = function _getProxyProp(element, property) {\n  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];\n},\n    _getScrollFunc = function _getScrollFunc(element, _ref) {\n  var s = _ref.s,\n      sc = _ref.sc;\n\n  var i = _scrollers.indexOf(element),\n      offset = sc === _vertical.sc ? 1 : 2;\n\n  !~i && (i = _scrollers.push(element) - 1);\n  return _scrollers[i + offset] || (_scrollers[i + offset] = _getProxyProp(element, s) || (_isViewport(element) ? sc : function (value) {\n    return arguments.length ? element[s] = value : element[s];\n  }));\n},\n    _getBoundsFunc = function _getBoundsFunc(element) {\n  return _getProxyProp(element, \"getBoundingClientRect\") || (_isViewport(element) ? function () {\n    _winOffsets.width = _win.innerWidth;\n    _winOffsets.height = _win.innerHeight;\n    return _winOffsets;\n  } : function () {\n    return _getBounds(element);\n  });\n},\n    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref2) {\n  var d = _ref2.d,\n      d2 = _ref2.d2,\n      a = _ref2.a;\n  return (a = _getProxyProp(scroller, \"getBoundingClientRect\")) ? function () {\n    return a()[d];\n  } : function () {\n    return (isViewport ? _win[\"inner\" + d2] : scroller[\"client\" + d2]) || 0;\n  };\n},\n    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {\n  return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {\n    return _winOffsets;\n  };\n},\n    _maxScroll = function _maxScroll(element, _ref3) {\n  var s = _ref3.s,\n      d2 = _ref3.d2,\n      d = _ref3.d,\n      a = _ref3.a;\n  return (s = \"scroll\" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? Math.max(_docEl[s], _body[s]) - (_win[\"inner\" + d2] || _docEl[\"client\" + d2] || _body[\"client\" + d2]) : element[s] - element[\"offset\" + d2];\n},\n    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {\n  for (var i = 0; i < _autoRefresh.length; i += 3) {\n    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\n  }\n},\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === \"number\";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === \"object\";\n},\n    _callIfFunc = function _callIfFunc(value) {\n  return _isFunction(value) && value();\n},\n    _combineFunc = function _combineFunc(f1, f2) {\n  return function () {\n    var result1 = _callIfFunc(f1),\n        result2 = _callIfFunc(f2);\n\n    return function () {\n      _callIfFunc(result1);\n\n      _callIfFunc(result2);\n    };\n  };\n},\n    _abs = Math.abs,\n    _scrollLeft = \"scrollLeft\",\n    _scrollTop = \"scrollTop\",\n    _left = \"left\",\n    _top = \"top\",\n    _right = \"right\",\n    _bottom = \"bottom\",\n    _width = \"width\",\n    _height = \"height\",\n    _Right = \"Right\",\n    _Left = \"Left\",\n    _Top = \"Top\",\n    _Bottom = \"Bottom\",\n    _padding = \"padding\",\n    _margin = \"margin\",\n    _Width = \"Width\",\n    _Height = \"Height\",\n    _px = \"px\",\n    _horizontal = {\n  s: _scrollLeft,\n  p: _left,\n  p2: _Left,\n  os: _right,\n  os2: _Right,\n  d: _width,\n  d2: _Width,\n  a: \"x\",\n  sc: function sc(value) {\n    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n  }\n},\n    _vertical = {\n  s: _scrollTop,\n  p: _top,\n  p2: _Top,\n  os: _bottom,\n  os2: _Bottom,\n  d: _height,\n  d2: _Height,\n  a: \"y\",\n  op: _horizontal,\n  sc: function sc(value) {\n    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n  }\n},\n    _getComputedStyle = function _getComputedStyle(element) {\n  return _win.getComputedStyle(element);\n},\n    _makePositionable = function _makePositionable(element) {\n  return element.style.position = _getComputedStyle(element).position === \"absolute\" ? \"absolute\" : \"relative\";\n},\n    // if the element already has position: absolute, leave that, otherwise make it position: relative\n_setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n\n  return obj;\n},\n    //_isInViewport = element => (element = _getBounds(element)) && !(element.top > (_win.innerHeight || _docEl.clientHeight) || element.bottom < 0 || element.left > (_win.innerWidth || _docEl.clientWidth) || element.right < 0) && element,\n_getBounds = function _getBounds(element, withoutTransforms) {\n  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {\n    x: 0,\n    y: 0,\n    xPercent: 0,\n    yPercent: 0,\n    rotation: 0,\n    rotationX: 0,\n    rotationY: 0,\n    scale: 1,\n    skewX: 0,\n    skewY: 0\n  }).progress(1),\n      bounds = element.getBoundingClientRect();\n  tween && tween.progress(0).kill();\n  return bounds;\n},\n    _getSize = function _getSize(element, _ref4) {\n  var d2 = _ref4.d2;\n  return element[\"offset\" + d2] || element[\"client\" + d2] || 0;\n},\n    _getLabels = function _getLabels(animation) {\n  return function (value) {\n    var a = [],\n        labels = animation.labels,\n        duration = animation.duration(),\n        p;\n\n    for (p in labels) {\n      a.push(labels[p] / duration);\n    }\n\n    return gsap.utils.snap(a, value);\n  };\n},\n    _multiListener = function _multiListener(func, element, types, callback) {\n  return types.split(\",\").forEach(function (type) {\n    return func(element, type, callback);\n  });\n},\n    _addListener = function _addListener(element, type, func) {\n  return element.addEventListener(type, func, {\n    passive: true\n  });\n},\n    _removeListener = function _removeListener(element, type, func) {\n  return element.removeEventListener(type, func);\n},\n    _markerDefaults = {\n  startColor: \"green\",\n  endColor: \"red\",\n  indent: 0,\n  fontSize: \"16px\",\n  fontWeight: \"normal\"\n},\n    _defaults = {\n  toggleActions: \"play\",\n  anticipatePin: 0\n},\n    _keywords = {\n  top: 0,\n  left: 0,\n  center: 0.5,\n  bottom: 1,\n  right: 1\n},\n    _offsetToPx = function _offsetToPx(value, size) {\n  if (_isString(value)) {\n    var eqIndex = value.indexOf(\"=\"),\n        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n\n    if (relative) {\n      value.indexOf(\"%\") > eqIndex && (relative *= size / 100);\n      value = value.substr(0, eqIndex - 1);\n    }\n\n    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n  }\n\n  return value;\n},\n    _createMarker = function _createMarker(type, name, container, direction, _ref5, offset, matchWidthEl) {\n  var startColor = _ref5.startColor,\n      endColor = _ref5.endColor,\n      fontSize = _ref5.fontSize,\n      indent = _ref5.indent,\n      fontWeight = _ref5.fontWeight;\n\n  var e = _doc.createElement(\"div\"),\n      useFixedPosition = _isViewport(container) || _getProxyProp(container, \"pinType\") === \"fixed\",\n      isScroller = type.indexOf(\"scroller\") !== -1,\n      parent = useFixedPosition ? _body : container,\n      isStart = type.indexOf(\"start\") !== -1,\n      color = isStart ? startColor : endColor,\n      css = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n\n  css += \"position:\" + (isScroller && useFixedPosition ? \"fixed;\" : \"absolute;\");\n  (isScroller || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n  matchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n  e._isStart = isStart;\n  e.setAttribute(\"class\", \"gsap-marker-\" + type);\n  e.style.cssText = css;\n  e.innerText = name || name === 0 ? type + \"-\" + name : type;\n  parent.insertBefore(e, parent.children[0]);\n  e._offset = e[\"offset\" + direction.op.d2];\n\n  _positionMarker(e, 0, direction, isStart);\n\n  return e;\n},\n    _positionMarker = function _positionMarker(marker, start, direction, flipped) {\n  var vars = {\n    display: \"block\"\n  },\n      side = direction[flipped ? \"os2\" : \"p2\"],\n      oppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n  marker._isFlipped = flipped;\n  vars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n  vars[direction.a] = flipped ? 1 : 0;\n  vars[\"border\" + side + _Width] = 1;\n  vars[\"border\" + oppositeSide + _Width] = 0;\n  vars[direction.p] = start;\n  gsap.set(marker, vars);\n},\n    _triggers = [],\n    _ids = {},\n    _sync = function _sync() {\n  return _request || (_request = _raf(_updateAll));\n},\n    _onScroll = function _onScroll() {\n  if (!_request) {\n    _request = _raf(_updateAll);\n    _lastScrollTime || _dispatch(\"scrollStart\");\n    _lastScrollTime = _getTime();\n  }\n},\n    _onResize = function _onResize() {\n  return !_refreshing && _resizeDelay.restart(true);\n},\n    // ignore resizes triggered by refresh()\n_listeners = {},\n    _emptyArray = [],\n    _media = [],\n    _creatingMedia,\n    // when ScrollTrigger.matchMedia() is called, we record the current media key here (like \"(min-width: 800px)\") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a \"media\" property on the instance.\n_lastMediaTick,\n    _onMediaChange = function _onMediaChange(e) {\n  var tick = gsap.ticker.frame,\n      matches = [],\n      i = 0,\n      index;\n\n  if (_lastMediaTick !== tick || _startup) {\n    _revertAll();\n\n    for (; i < _media.length; i += 4) {\n      index = _win.matchMedia(_media[i]).matches;\n\n      if (index !== _media[i + 3]) {\n        // note: some browsers fire the matchMedia event multiple times, like when going full screen, so we shouldn't call the function multiple times. Check to see if it's already matched.\n        _media[i + 3] = index;\n        index ? matches.push(i) : _revertAll(1, _media[i]) || _isFunction(_media[i + 2]) && _media[i + 2](); // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\n      }\n    }\n\n    _revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.\n\n\n    for (i = 0; i < matches.length; i++) {\n      index = matches[i];\n      _creatingMedia = _media[index];\n      _media[index + 2] = _media[index + 1](e);\n    }\n\n    _creatingMedia = 0;\n\n    _refreshAll(0, 1);\n\n    _lastMediaTick = tick;\n\n    _dispatch(\"matchMedia\");\n  }\n},\n    _softRefresh = function _softRefresh() {\n  return _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true);\n},\n    _dispatch = function _dispatch(type) {\n  return _listeners[type] && _listeners[type].map(function (f) {\n    return f();\n  }) || _emptyArray;\n},\n    _savedStyles = [],\n    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n_revertRecorded = function _revertRecorded(media) {\n  for (var i = 0; i < _savedStyles.length; i += 4) {\n    if (!media || _savedStyles[i + 3] === media) {\n      _savedStyles[i].style.cssText = _savedStyles[i + 1];\n      _savedStyles[i + 2].uncache = 1;\n    }\n  }\n},\n    _revertAll = function _revertAll(kill, media) {\n  var trigger;\n\n  for (_i = 0; _i < _triggers.length; _i++) {\n    trigger = _triggers[_i];\n\n    if (!media || trigger.media === media) {\n      if (kill) {\n        trigger.kill(1);\n      } else {\n        trigger.scroll.rec || (trigger.scroll.rec = trigger.scroll()); // record the scroll positions so that in each refresh() we can ensure that it doesn't shift. Remember, pinning can make things change around, especially if the same element is pinned multiple times. If one was already recorded, don't re-record because unpinning may have occurred and made it shorter.\n\n        trigger.revert();\n      }\n    }\n  }\n\n  _revertRecorded(media);\n\n  media || _dispatch(\"revert\");\n},\n    _refreshAll = function _refreshAll(force, skipRevert) {\n  if (_lastScrollTime && !force) {\n    _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\n    return;\n  }\n\n  var refreshInits = _dispatch(\"refreshInit\");\n\n  _sort && ScrollTrigger.sort();\n  skipRevert || _revertAll();\n\n  for (_i = 0; _i < _triggers.length; _i++) {\n    _triggers[_i].refresh();\n  }\n\n  refreshInits.forEach(function (result) {\n    return result && result.render && result.render(-1);\n  }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n\n  _i = _triggers.length;\n\n  while (_i--) {\n    _triggers[_i].scroll.rec = 0;\n  }\n\n  _resizeDelay.pause();\n\n  _dispatch(\"refresh\");\n},\n    _lastScroll = 0,\n    _direction = 1,\n    _updateAll = function _updateAll() {\n  var l = _triggers.length,\n      time = _getTime(),\n      recordVelocity = time - _time1 >= 50,\n      scroll = l && _triggers[0].scroll();\n\n  _direction = _lastScroll > scroll ? -1 : 1;\n  _lastScroll = scroll;\n\n  if (recordVelocity) {\n    if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n      _lastScrollTime = 0;\n\n      _dispatch(\"scrollEnd\");\n    }\n\n    _time2 = _time1;\n    _time1 = time;\n  }\n\n  if (_direction < 0) {\n    _i = l;\n\n    while (_i--) {\n      _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n    }\n\n    _direction = 1;\n  } else {\n    for (_i = 0; _i < l; _i++) {\n      _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n    }\n  }\n\n  _request = 0;\n},\n    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, \"display\", \"flexShrink\", \"float\"],\n    _stateProps = _propNamesToCopy.concat([_width, _height, \"boxSizing\", \"max\" + _Width, \"max\" + _Height, \"position\", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),\n    _swapPinOut = function _swapPinOut(pin, spacer, state) {\n  _setState(state);\n\n  if (pin.parentNode === spacer) {\n    var parent = spacer.parentNode;\n\n    if (parent) {\n      parent.insertBefore(pin, spacer);\n      parent.removeChild(spacer);\n    }\n  }\n},\n    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {\n  if (pin.parentNode !== spacer) {\n    var i = _propNamesToCopy.length,\n        spacerStyle = spacer.style,\n        pinStyle = pin.style,\n        p;\n\n    while (i--) {\n      p = _propNamesToCopy[i];\n      spacerStyle[p] = cs[p];\n    }\n\n    spacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n    cs.display === \"inline\" && (spacerStyle.display = \"inline-block\");\n    pinStyle[_bottom] = pinStyle[_right] = \"auto\";\n    spacerStyle.overflow = \"visible\";\n    spacerStyle.boxSizing = \"border-box\";\n    spacerStyle[_width] = _getSize(pin, _horizontal) + _px;\n    spacerStyle[_height] = _getSize(pin, _vertical) + _px;\n    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n\n    _setState(spacerState);\n\n    pinStyle[_width] = pinStyle[\"max\" + _Width] = cs[_width];\n    pinStyle[_height] = pinStyle[\"max\" + _Height] = cs[_height];\n    pinStyle[_padding] = cs[_padding];\n    pin.parentNode.insertBefore(spacer, pin);\n    spacer.appendChild(pin);\n  }\n},\n    _capsExp = /([A-Z])/g,\n    _setState = function _setState(state) {\n  if (state) {\n    var style = state.t.style,\n        l = state.length,\n        i = 0,\n        p,\n        value;\n\n    for (; i < l; i += 2) {\n      value = state[i + 1];\n      p = state[i];\n\n      if (value) {\n        style[p] = value;\n      } else if (style[p]) {\n        style.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n      }\n    }\n  }\n},\n    _getState = function _getState(element) {\n  // returns an array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n  var l = _stateProps.length,\n      style = element.style,\n      state = [],\n      i = 0;\n\n  for (; i < l; i++) {\n    state.push(_stateProps[i], style[_stateProps[i]]);\n  }\n\n  state.t = element;\n  return state;\n},\n    _copyState = function _copyState(state, override, omitOffsets) {\n  var result = [],\n      l = state.length,\n      i = omitOffsets ? 8 : 0,\n      // skip top, left, right, bottom if omitOffsets is true\n  p;\n\n  for (; i < l; i += 2) {\n    p = state[i];\n    result.push(p, p in override ? override[p] : state[i + 1]);\n  }\n\n  result.t = state.t;\n  return result;\n},\n    _winOffsets = {\n  left: 0,\n  top: 0\n},\n    _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax) {\n  _isFunction(value) && (value = value(self));\n\n  if (_isString(value) && value.substr(0, 3) === \"max\") {\n    value = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n  }\n\n  if (!_isNumber(value)) {\n    _isFunction(trigger) && (trigger = trigger(self));\n\n    var element = _toArray(trigger)[0] || _body,\n        bounds = _getBounds(element) || {},\n        offsets = value.split(\" \"),\n        localOffset,\n        globalOffset,\n        display;\n\n    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === \"none\") {\n      // if display is \"none\", it won't report getBoundingClientRect() properly\n      display = element.style.display;\n      element.style.display = \"block\";\n      bounds = _getBounds(element);\n      display ? element.style.display = display : element.style.removeProperty(\"display\");\n    }\n\n    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n    globalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n    scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n  } else if (markerScroller) {\n    _positionMarker(markerScroller, scrollerSize, direction, true);\n  }\n\n  if (marker) {\n    var position = value + scrollerSize,\n        isStart = marker._isStart;\n    scrollerMax = \"scroll\" + direction.d2;\n\n    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[scrollerMax], _docEl[scrollerMax]) : marker.parentNode[scrollerMax]) <= position + 1);\n\n    if (useFixedPosition) {\n      scrollerBounds = _getBounds(markerScroller);\n      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\n    }\n  }\n\n  return Math.round(value);\n},\n    _prefixExp = /(?:webkit|moz|length|cssText)/i,\n    _reparent = function _reparent(element, parent, top, left) {\n  if (element.parentNode !== parent) {\n    var style = element.style,\n        p,\n        cs;\n\n    if (parent === _body) {\n      element._stOrig = style.cssText; // record original inline styles so we can revert them later\n\n      cs = _getComputedStyle(element);\n\n      for (p in cs) {\n        // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n          style[p] = cs[p];\n        }\n      }\n\n      style.top = top;\n      style.left = left;\n    } else {\n      style.cssText = element._stOrig;\n    }\n\n    gsap.core.getCache(element).uncache = 1;\n    parent.appendChild(element);\n  }\n},\n    // returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n_getTweenCreator = function _getTweenCreator(scroller, direction) {\n  var getScroll = _getScrollFunc(scroller, direction),\n      prop = \"_scroll\" + direction.p2,\n      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n  lastScroll1,\n      lastScroll2,\n      getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {\n    var tween = getTween.tween,\n        onComplete = vars.onComplete,\n        modifiers = {};\n    tween && tween.kill();\n    lastScroll1 = Math.round(initialValue);\n    vars[prop] = scrollTo;\n    vars.modifiers = modifiers;\n\n    modifiers[prop] = function (value) {\n      value = Math.round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.\n\n      if (value !== lastScroll1 && value !== lastScroll2) {\n        // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that!\n        tween.kill();\n        getTween.tween = 0;\n      } else {\n        value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;\n      }\n\n      lastScroll2 = lastScroll1;\n      return lastScroll1 = Math.round(value);\n    };\n\n    vars.onComplete = function () {\n      getTween.tween = 0;\n      onComplete && onComplete.call(tween);\n    };\n\n    tween = getTween.tween = gsap.to(scroller, vars);\n    return tween;\n  };\n\n  scroller[prop] = getScroll;\n  return getTween;\n};\n\n_horizontal.op = _vertical;\nexport var ScrollTrigger = /*#__PURE__*/function () {\n  function ScrollTrigger(vars, animation) {\n    _coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n    this.init(vars, animation);\n  }\n\n  var _proto = ScrollTrigger.prototype;\n\n  _proto.init = function init(vars, animation) {\n    this.progress = 0;\n    this.vars && this.kill(1); // in case it's being initted again\n\n    if (!_enabled) {\n      this.update = this.refresh = this.kill = _passThrough;\n      return;\n    }\n\n    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\n      trigger: vars\n    } : vars, _defaults);\n\n    var direction = vars.horizontal ? _horizontal : _vertical,\n        _vars = vars,\n        onUpdate = _vars.onUpdate,\n        toggleClass = _vars.toggleClass,\n        id = _vars.id,\n        onToggle = _vars.onToggle,\n        onRefresh = _vars.onRefresh,\n        scrub = _vars.scrub,\n        trigger = _vars.trigger,\n        pin = _vars.pin,\n        pinSpacing = _vars.pinSpacing,\n        invalidateOnRefresh = _vars.invalidateOnRefresh,\n        anticipatePin = _vars.anticipatePin,\n        onScrubComplete = _vars.onScrubComplete,\n        onSnapComplete = _vars.onSnapComplete,\n        once = _vars.once,\n        snap = _vars.snap,\n        pinReparent = _vars.pinReparent,\n        isToggle = !scrub && scrub !== 0,\n        scroller = _toArray(vars.scroller || _win)[0],\n        scrollerCache = gsap.core.getCache(scroller),\n        isViewport = _isViewport(scroller),\n        useFixedPosition = \"pinType\" in vars ? vars.pinType === \"fixed\" : isViewport || _getProxyProp(scroller, \"pinType\") === \"fixed\",\n        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],\n        toggleActions = isToggle && vars.toggleActions.split(\" \"),\n        markers = \"markers\" in vars ? vars.markers : _defaults.markers,\n        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0,\n        self = this,\n        onRefreshInit = vars.onRefreshInit && function () {\n      return vars.onRefreshInit(self);\n    },\n        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),\n        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),\n        tweenTo,\n        pinCache,\n        snapFunc,\n        isReverted,\n        scroll1,\n        scroll2,\n        start,\n        end,\n        markerStart,\n        markerEnd,\n        markerStartTrigger,\n        markerEndTrigger,\n        markerVars,\n        change,\n        pinOriginalState,\n        pinActiveState,\n        pinState,\n        spacer,\n        offset,\n        pinGetter,\n        pinSetter,\n        pinStart,\n        pinChange,\n        spacingStart,\n        spacerState,\n        markerStartSetter,\n        markerEndSetter,\n        cs,\n        snap1,\n        snap2,\n        scrubTween,\n        scrubSmooth,\n        snapDurClamp,\n        snapDelayedCall,\n        prevProgress,\n        prevScroll,\n        prevAnimProgress;\n\n    self.media = _creatingMedia;\n    anticipatePin *= 45;\n\n    _triggers.push(self);\n\n    self.scroller = scroller;\n    self.scroll = _getScrollFunc(scroller, direction);\n    scroll1 = self.scroll();\n    self.vars = vars;\n    animation = animation || vars.animation;\n    \"refreshPriority\" in vars && (_sort = 1);\n    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n      top: _getTweenCreator(scroller, _vertical),\n      left: _getTweenCreator(scroller, _horizontal)\n    };\n    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n\n    if (animation) {\n      animation.vars.lazy = false;\n      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);\n      self.animation = animation.pause();\n      animation.scrollTrigger = self;\n      scrubSmooth = _isNumber(scrub) && scrub;\n      scrubSmooth && (scrubTween = gsap.to(animation, {\n        ease: \"power3\",\n        duration: scrubSmooth,\n        onComplete: function onComplete() {\n          return onScrubComplete && onScrubComplete(self);\n        }\n      }));\n      snap1 = 0;\n      id || (id = animation.vars.id);\n    }\n\n    if (snap) {\n      _isObject(snap) || (snap = {\n        snapTo: snap\n      });\n      gsap.set(isViewport ? [_body, _docEl] : scroller, {\n        scrollBehavior: \"auto\"\n      }); // smooth scrolling doesn't work with snap.\n\n      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getLabels(animation) : gsap.utils.snap(snap.snapTo);\n      snapDurClamp = snap.duration || {\n        min: 0.1,\n        max: 2\n      };\n      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {\n        if (Math.abs(self.getVelocity()) < 10 && !_pointerIsDown) {\n          var totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,\n              velocity = (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,\n              change1 = _abs(velocity / 2) * velocity / 0.185,\n              naturalEnd = totalProgress + change1,\n              endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),\n              scroll = self.scroll(),\n              endScroll = Math.round(start + endValue * change),\n              tween = tweenTo.tween;\n\n          if (scroll <= end && scroll >= start && endScroll !== scroll) {\n            if (tween && !tween._initted && tween.data <= Math.abs(endScroll - scroll)) {\n              // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n              return;\n            }\n\n            tweenTo(endScroll, {\n              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n              ease: snap.ease || \"power3\",\n              data: Math.abs(endScroll - scroll),\n              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n              onComplete: function onComplete() {\n                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                onSnapComplete && onSnapComplete(self);\n              }\n            }, scroll, change1 * change, endScroll - scroll - change1 * change);\n          }\n        } else if (self.isActive) {\n          snapDelayedCall.restart(true);\n        }\n      }).pause();\n    }\n\n    id && (_ids[id] = self);\n    trigger = self.trigger = _toArray(trigger || pin)[0];\n    pin = pin === true ? trigger : _toArray(pin)[0];\n    _isString(toggleClass) && (toggleClass = {\n      targets: trigger,\n      className: toggleClass\n    });\n\n    if (pin) {\n      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.\n\n      self.pin = pin;\n      vars.force3D !== false && gsap.set(pin, {\n        force3D: true\n      });\n      pinCache = gsap.core.getCache(pin);\n\n      if (!pinCache.spacer) {\n        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n        pinCache.spacer = spacer = _doc.createElement(\"div\");\n        spacer.setAttribute(\"class\", \"pin-spacer\" + (id ? \" pin-spacer-\" + id : \"\"));\n        pinCache.pinState = pinOriginalState = _getState(pin);\n      } else {\n        pinOriginalState = pinCache.pinState;\n      }\n\n      self.spacer = spacer = pinCache.spacer;\n      cs = _getComputedStyle(pin);\n      spacingStart = cs[pinSpacing + direction.os2];\n      pinGetter = gsap.getProperty(pin);\n      pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = \"hidden\"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\n\n      _swapPinIn(pin, spacer, cs);\n\n      pinState = _getState(pin);\n    }\n\n    if (markers) {\n      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n      markerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n      markerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n      offset = markerStartTrigger[\"offset\" + direction.op.d2];\n      markerStart = _createMarker(\"start\", id, scroller, direction, markerVars, offset);\n      markerEnd = _createMarker(\"end\", id, scroller, direction, markerVars, offset);\n\n      if (!useFixedPosition) {\n        _makePositionable(scroller);\n\n        gsap.set([markerStartTrigger, markerEndTrigger], {\n          force3D: true\n        });\n        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n      }\n    }\n\n    self.revert = function (revert) {\n      var r = revert !== false || !self.enabled,\n          prevRefreshing = _refreshing;\n\n      if (r !== isReverted) {\n        if (r) {\n          prevScroll = Math.max(self.scroll(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n\n          prevProgress = self.progress;\n          prevAnimProgress = animation && animation.progress();\n        }\n\n        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\n          return m.style.display = r ? \"none\" : \"block\";\n        });\n        r && (_refreshing = 1);\n        self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.\n\n        _refreshing = prevRefreshing;\n        pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));\n        isReverted = r;\n      }\n    };\n\n    self.refresh = function (soft) {\n      if (_refreshing || !self.enabled) {\n        return;\n      }\n\n      if (pin && soft && _lastScrollTime) {\n        _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\n        return;\n      }\n\n      _refreshing = 1;\n      scrubTween && scrubTween.kill();\n      invalidateOnRefresh && animation && animation.progress(0).invalidate();\n      isReverted || self.revert();\n\n      var size = getScrollerSize(),\n          scrollerBounds = getScrollerOffsets(),\n          max = _maxScroll(scroller, direction),\n          offset = 0,\n          otherPinOffset = 0,\n          parsedEnd = vars.end,\n          parsedEndTrigger = vars.endTrigger || trigger,\n          parsedStart = vars.start || (vars.start === 0 ? 0 : pin || !trigger ? \"0 0\" : \"0 100%\"),\n          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,\n          i = triggerIndex,\n          cs,\n          bounds,\n          scroll,\n          isVertical,\n          override,\n          curTrigger,\n          curPin,\n          oppositeScroll;\n\n      while (i--) {\n        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n        curPin = _triggers[i].pin;\n        curPin && (curPin === trigger || curPin === pin) && _triggers[i].revert();\n      }\n\n      start = _parsePosition(parsedStart, trigger, size, direction, self.scroll(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max) || (pin ? -0.001 : 0);\n      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n\n      if (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n        if (~parsedEnd.indexOf(\" \")) {\n          parsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n        } else {\n          offset = _offsetToPx(parsedEnd.substr(2), size);\n          parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n\n          parsedEndTrigger = trigger;\n        }\n      }\n\n      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, self.scroll() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max)) || -0.001;\n      change = end - start || (start -= 0.01) && 0.001;\n      offset = 0;\n      i = triggerIndex;\n\n      while (i--) {\n        curTrigger = _triggers[i];\n        curPin = curTrigger.pin;\n\n        if (curPin && curTrigger.start - curTrigger._pinPush < start) {\n          cs = curTrigger.end - curTrigger.start;\n          curPin === trigger && (offset += cs);\n          curPin === pin && (otherPinOffset += cs);\n        }\n      }\n\n      start += offset;\n      end += offset;\n      self._pinPush = otherPinOffset;\n\n      if (markerStart && offset) {\n        // offset the markers if necessary\n        cs = {};\n        cs[direction.a] = \"+=\" + offset;\n        gsap.set([markerStart, markerEnd], cs);\n      }\n\n      if (pin) {\n        cs = _getComputedStyle(pin);\n        isVertical = direction === _vertical;\n        scroll = self.scroll(); // recalculate because the triggers can affect the scroll\n\n        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n        !max && end > 1 && ((isViewport ? _body : scroller).style[\"overflow-\" + direction.a] = \"scroll\"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\n\n        _swapPinIn(pin, spacer, cs);\n\n        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n\n        bounds = _getBounds(pin, true);\n        oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();\n\n        if (pinSpacing) {\n          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];\n          spacerState.t = spacer;\n          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\n          i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\n\n          _setState(spacerState);\n\n          useFixedPosition && self.scroll(prevScroll);\n        }\n\n        if (useFixedPosition) {\n          override = {\n            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,\n            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,\n            boxSizing: \"border-box\",\n            position: \"fixed\"\n          };\n          override[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n          override[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n          override[_padding] = cs[_padding];\n          override[_padding + _Top] = cs[_padding + _Top];\n          override[_padding + _Right] = cs[_padding + _Right];\n          override[_padding + _Bottom] = cs[_padding + _Bottom];\n          override[_padding + _Left] = cs[_padding + _Left];\n          pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n        }\n\n        if (animation) {\n          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n          animation.progress(1, true);\n          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n          change !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n\n          animation.progress(0, true);\n        } else {\n          pinChange = change;\n        }\n      } else if (trigger && self.scroll()) {\n        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n        bounds = trigger.parentNode;\n\n        while (bounds && bounds !== _body) {\n          if (bounds._pinOffset) {\n            start -= bounds._pinOffset;\n            end -= bounds._pinOffset;\n          }\n\n          bounds = bounds.parentNode;\n        }\n      }\n\n      for (i = 0; i < triggerIndex; i++) {\n        // make sure we revert from first to last to make sure things reach their end state properly\n        curTrigger = _triggers[i].pin;\n        curTrigger && (curTrigger === trigger || curTrigger === pin) && _triggers[i].revert(false);\n      }\n\n      self.start = start;\n      self.end = end;\n      scroll1 = scroll2 = self.scroll(); // reset velocity\n\n      scroll1 < prevScroll && self.scroll(prevScroll);\n      self.revert(false);\n      _refreshing = 0;\n      prevAnimProgress && isToggle && animation.progress(prevAnimProgress, true);\n\n      if (prevProgress !== self.progress) {\n        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n        scrubTween && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n\n        self.progress = prevProgress;\n        self.update();\n      }\n\n      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n      onRefresh && onRefresh(self);\n    };\n\n    self.getVelocity = function () {\n      return (self.scroll() - scroll2) / (_getTime() - _time2) * 1000 || 0;\n    };\n\n    self.update = function (reset, recordVelocity) {\n      var scroll = self.scroll(),\n          p = reset ? 0 : (scroll - start) / change,\n          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,\n          prevProgress = self.progress,\n          isActive,\n          wasActive,\n          toggleState,\n          action,\n          stateChanged,\n          toggled;\n\n      if (recordVelocity) {\n        scroll2 = scroll1;\n        scroll1 = scroll;\n\n        if (snap) {\n          snap2 = snap1;\n          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n        }\n      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n\n\n      anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);\n\n      if (clipped !== prevProgress && self.enabled) {\n        isActive = self.isActive = !!clipped && clipped < 1;\n        wasActive = !!prevProgress && prevProgress < 1;\n        toggled = isActive !== wasActive;\n        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n\n        self.direction = clipped > prevProgress ? 1 : -1;\n        self.progress = clipped;\n\n        if (!isToggle) {\n          if (scrubTween && !_refreshing && !_startup) {\n            scrubTween.vars.totalProgress = clipped;\n            scrubTween.invalidate().restart();\n          } else if (animation) {\n            animation.totalProgress(clipped, !!_refreshing);\n          }\n        }\n\n        if (pin) {\n          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n\n          if (!useFixedPosition) {\n            pinSetter(pinStart + pinChange * clipped);\n          } else if (stateChanged) {\n            action = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n\n            if (pinReparent) {\n              if (!reset && (isActive || action)) {\n                var bounds = _getBounds(pin, true),\n                    _offset = scroll - start;\n\n                _reparent(pin, _body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);\n              } else {\n                _reparent(pin, spacer);\n              }\n            }\n\n            _setState(isActive || action ? pinActiveState : pinState);\n\n            pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !action ? pinChange : 0));\n          }\n        }\n\n        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {\n          return el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className);\n        }); // classes could affect positioning, so do it even if reset or refreshing is true.\n\n        onUpdate && !isToggle && !reset && onUpdate(self);\n\n        if (stateChanged && !_refreshing) {\n          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n\n          if (isToggle) {\n            action = !toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n\n            if (animation && (action === \"complete\" || action === \"reset\" || action in animation)) {\n              if (action === \"complete\") {\n                animation.pause().totalProgress(1);\n              } else if (action === \"reset\") {\n                animation.restart(true).pause();\n              } else {\n                animation[action]();\n              }\n            }\n\n            onUpdate && onUpdate(self);\n          }\n\n          if (toggled || !_limitCallbacks) {\n            // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n            onToggle && toggled && onToggle(self);\n            callbacks[toggleState] && callbacks[toggleState](self);\n            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.\n\n            if (!toggled) {\n              // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n              toggleState = clipped === 1 ? 1 : 3;\n              callbacks[toggleState] && callbacks[toggleState](self);\n            }\n          }\n        } else if (isToggle && onUpdate && !_refreshing) {\n          onUpdate(self);\n        }\n      } // update absolutely-positioned markers (only if the scroller isn't the viewport)\n\n\n      if (markerEndSetter) {\n        markerStartSetter(scroll + (markerStartTrigger._isFlipped ? 1 : 0));\n        markerEndSetter(scroll);\n      }\n    };\n\n    self.enable = function () {\n      if (!self.enabled) {\n        self.enabled = true;\n\n        _addListener(scroller, \"resize\", _onResize);\n\n        _addListener(scroller, \"scroll\", _onScroll);\n\n        onRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n        !animation || !animation.add ? self.refresh() : gsap.delayedCall(0.01, function () {\n          return start || end || self.refresh();\n        }) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick.\n      }\n    };\n\n    self.disable = function (reset, allowAnimation) {\n      if (self.enabled) {\n        reset !== false && self.revert();\n        self.enabled = self.isActive = false;\n        allowAnimation || scrubTween && scrubTween.pause();\n        prevScroll = 0;\n        pinCache && (pinCache.uncache = 1);\n        onRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\n        if (snapDelayedCall) {\n          snapDelayedCall.pause();\n          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n        }\n\n        if (!isViewport) {\n          var i = _triggers.length;\n\n          while (i--) {\n            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n              return; //don't remove the listeners if there are still other triggers referencing it.\n            }\n          }\n\n          _removeListener(scroller, \"resize\", _onResize);\n\n          _removeListener(scroller, \"scroll\", _onScroll);\n        }\n      }\n    };\n\n    self.kill = function (revert, allowAnimation) {\n      self.disable(revert, allowAnimation);\n      id && delete _ids[id];\n\n      var i = _triggers.indexOf(self);\n\n      _triggers.splice(i, 1);\n\n      i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n\n      if (animation) {\n        animation.scrollTrigger = null;\n        revert && animation.render(-1);\n        allowAnimation || animation.kill();\n      }\n\n      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\n        return m.parentNode.removeChild(m);\n      });\n      pinCache && (pinCache.uncache = 1);\n    };\n\n    self.enable();\n  };\n\n  ScrollTrigger.register = function register(core) {\n    if (!_coreInitted) {\n      gsap = core || _getGSAP();\n\n      if (_windowExists() && window.document) {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n      }\n\n      if (gsap) {\n        _toArray = gsap.utils.toArray;\n        _clamp = gsap.utils.clamp;\n        gsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n\n        if (_body) {\n          _raf = _win.requestAnimationFrame || function (f) {\n            return setTimeout(f, 16);\n          };\n\n          _addListener(_win, \"mousewheel\", _onScroll);\n\n          _root = [_win, _doc, _docEl, _body];\n\n          _addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n\n\n          var bodyStyle = _body.style,\n              border = bodyStyle.borderTop,\n              bounds;\n          bodyStyle.borderTop = \"1px solid #000\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n\n          bounds = _getBounds(_body);\n          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n\n          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;\n          border ? bodyStyle.borderTop = border : bodyStyle.removeProperty(\"border-top\");\n          _syncInterval = setInterval(_sync, 200);\n          gsap.delayedCall(0.5, function () {\n            return _startup = 0;\n          });\n\n          _addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n\n\n          _addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\n\n          _multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", function () {\n            return _pointerIsDown = 1;\n          });\n\n          _multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", function () {\n            return _pointerIsDown = 0;\n          });\n\n          _transformProp = gsap.utils.checkPrefix(\"transform\");\n\n          _stateProps.push(_transformProp);\n\n          _coreInitted = _getTime();\n          _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n          _autoRefresh = [_doc, \"visibilitychange\", function () {\n            var w = _win.innerWidth,\n                h = _win.innerHeight;\n\n            if (_doc.hidden) {\n              _prevWidth = w;\n              _prevHeight = h;\n            } else if (_prevWidth !== w || _prevHeight !== h) {\n              _onResize();\n            }\n          }, _doc, \"DOMContentLoaded\", _refreshAll, _win, \"load\", function () {\n            return _lastScrollTime || _refreshAll();\n          }, _win, \"resize\", _onResize];\n\n          _iterateAutoRefresh(_addListener);\n        }\n      }\n    }\n\n    return _coreInitted;\n  };\n\n  ScrollTrigger.defaults = function defaults(config) {\n    for (var p in config) {\n      _defaults[p] = config[p];\n    }\n  };\n\n  ScrollTrigger.kill = function kill() {\n    _enabled = 0;\n\n    _triggers.slice(0).forEach(function (trigger) {\n      return trigger.kill(1);\n    });\n  };\n\n  ScrollTrigger.config = function config(vars) {\n    \"limitCallbacks\" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n    var ms = vars.syncInterval;\n    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n    \"autoRefreshEvents\" in vars && (_iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\"));\n  };\n\n  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {\n    var t = _toArray(target)[0];\n\n    _isViewport(t) ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);\n  };\n\n  ScrollTrigger.matchMedia = function matchMedia(vars) {\n    // _media is populated in the following order: mediaQueryString, onMatch, onUnmatch, isMatched. So if there are two media queries, the Array would have a length of 8\n    var mq, p, i, func, result;\n\n    for (p in vars) {\n      i = _media.indexOf(p);\n      func = vars[p];\n      _creatingMedia = p;\n\n      if (p === \"all\") {\n        func();\n      } else {\n        mq = _win.matchMedia(p);\n\n        if (mq) {\n          mq.matches && (result = func());\n\n          if (~i) {\n            _media[i + 1] = _combineFunc(_media[i + 1], func);\n            _media[i + 2] = _combineFunc(_media[i + 2], result);\n          } else {\n            i = _media.length;\n\n            _media.push(p, func, result);\n\n            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n          }\n\n          _media[i + 3] = mq.matches;\n        }\n      }\n\n      _creatingMedia = 0;\n    }\n\n    return _media;\n  };\n\n  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {\n    query || (_media.length = 0);\n    query = _media.indexOf(query);\n    query >= 0 && _media.splice(query, 4);\n  };\n\n  return ScrollTrigger;\n}();\nScrollTrigger.version = \"3.5.1\";\n\nScrollTrigger.saveStyles = function (targets) {\n  return targets ? _toArray(targets).forEach(function (target) {\n    var i = _savedStyles.indexOf(target);\n\n    i >= 0 && _savedStyles.splice(i, 4);\n\n    _savedStyles.push(target, target.style.cssText, gsap.core.getCache(target), _creatingMedia);\n  }) : _savedStyles;\n};\n\nScrollTrigger.revert = function (soft, media) {\n  return _revertAll(!soft, media);\n};\n\nScrollTrigger.create = function (vars, animation) {\n  return new ScrollTrigger(vars, animation);\n};\n\nScrollTrigger.refresh = function (safe) {\n  return safe ? _onResize() : _refreshAll(true);\n};\n\nScrollTrigger.update = _updateAll;\n\nScrollTrigger.maxScroll = function (element, horizontal) {\n  return _maxScroll(element, horizontal ? _horizontal : _vertical);\n};\n\nScrollTrigger.getScrollFunc = function (element, horizontal) {\n  return _getScrollFunc(_toArray(element)[0], horizontal ? _horizontal : _vertical);\n};\n\nScrollTrigger.getById = function (id) {\n  return _ids[id];\n};\n\nScrollTrigger.getAll = function () {\n  return _triggers.slice(0);\n};\n\nScrollTrigger.isScrolling = function () {\n  return !!_lastScrollTime;\n};\n\nScrollTrigger.addEventListener = function (type, callback) {\n  var a = _listeners[type] || (_listeners[type] = []);\n  ~a.indexOf(callback) || a.push(callback);\n};\n\nScrollTrigger.removeEventListener = function (type, callback) {\n  var a = _listeners[type],\n      i = a && a.indexOf(callback);\n  i >= 0 && a.splice(i, 1);\n};\n\nScrollTrigger.batch = function (targets, vars) {\n  var result = [],\n      varsCopy = {},\n      interval = vars.interval || 0.016,\n      batchMax = vars.batchMax || 1e9,\n      proxyCallback = function proxyCallback(type, callback) {\n    var elements = [],\n        triggers = [],\n        delay = gsap.delayedCall(interval, function () {\n      callback(elements, triggers);\n      elements = [];\n      triggers = [];\n    }).pause();\n    return function (self) {\n      elements.length || delay.restart(true);\n      elements.push(self.trigger);\n      triggers.push(self);\n      batchMax <= elements.length && delay.progress(1);\n    };\n  },\n      p;\n\n  for (p in vars) {\n    varsCopy[p] = p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\" ? proxyCallback(p, vars[p]) : vars[p];\n  }\n\n  if (_isFunction(batchMax)) {\n    batchMax = batchMax();\n\n    _addListener(ScrollTrigger, \"refresh\", function () {\n      return batchMax = vars.batchMax();\n    });\n  }\n\n  _toArray(targets).forEach(function (target) {\n    var config = {};\n\n    for (p in varsCopy) {\n      config[p] = varsCopy[p];\n    }\n\n    config.trigger = target;\n    result.push(ScrollTrigger.create(config));\n  });\n\n  return result;\n};\n\nScrollTrigger.sort = function (func) {\n  return _triggers.sort(func || function (a, b) {\n    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);\n  });\n};\n\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\nexport { ScrollTrigger as default };","/*!\n * strings: 3.5.1\n * https://greensock.com\n *\n * Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _trimExp = /(^\\s+|\\s+$)/g;\nexport var emojiExp = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF](?:[\\u200D\\uFE0F][\\uD800-\\uDBFF][\\uDC00-\\uDFFF]){2,}|\\uD83D\\uDC69(?:\\u200D(?:(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67|(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC6F\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3C-\\uDD3E\\uDDD6-\\uDDDF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642])\\uFE0F|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC68(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708]))\\uFE0F|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83D\\uDC69\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]))|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\u200D(?:(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDD1-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])?|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])\\uFE0F)/;\nexport function getText(e) {\n  var type = e.nodeType,\n      result = \"\";\n\n  if (type === 1 || type === 9 || type === 11) {\n    if (typeof e.textContent === \"string\") {\n      return e.textContent;\n    } else {\n      for (e = e.firstChild; e; e = e.nextSibling) {\n        result += getText(e);\n      }\n    }\n  } else if (type === 3 || type === 4) {\n    return e.nodeValue;\n  }\n\n  return result;\n}\nexport function splitInnerHTML(element, delimiter, trim) {\n  var node = element.firstChild,\n      result = [];\n\n  while (node) {\n    if (node.nodeType === 3) {\n      result.push.apply(result, emojiSafeSplit((node.nodeValue + \"\").replace(/^\\n+/g, \"\").replace(/\\s+/g, \" \"), delimiter, trim));\n    } else if ((node.nodeName + \"\").toLowerCase() === \"br\") {\n      result[result.length - 1] += \"<br>\";\n    } else {\n      result.push(node.outerHTML);\n    }\n\n    node = node.nextSibling;\n  }\n\n  return result;\n}\n/*\n//smaller kb version that only handles the simpler emoji's, which is often perfectly adequate.\n\nlet _emoji = \"[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2694-\\u2697]|\\uD83E[\\uDD10-\\uDD5D]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\",\n\t_emojiExp = new RegExp(_emoji),\n\t_emojiAndCharsExp = new RegExp(_emoji + \"|.\", \"g\"),\n\t_emojiSafeSplit = (text, delimiter, trim) => {\n\t\tif (trim) {\n\t\t\ttext = text.replace(_trimExp, \"\");\n\t\t}\n\t\treturn ((delimiter === \"\" || !delimiter) && _emojiExp.test(text)) ? text.match(_emojiAndCharsExp) : text.split(delimiter || \"\");\n\t};\n */\n\nexport function emojiSafeSplit(text, delimiter, trim) {\n  text += \"\"; // make sure it's cast as a string. Someone may pass in a number.\n\n  if (trim) {\n    text = text.replace(_trimExp, \"\");\n  }\n\n  if (delimiter && delimiter !== \"\") {\n    return text.replace(/>/g, \"&gt;\").replace(/</g, \"&lt;\").split(delimiter);\n  }\n\n  var result = [],\n      l = text.length,\n      i = 0,\n      j,\n      character;\n\n  for (; i < l; i++) {\n    character = text.charAt(i);\n\n    if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {\n      //special emoji characters use 2 or 4 unicode characters that we must keep together.\n      j = ((text.substr(i, 12).split(emojiExp) || [])[1] || \"\").length || 2;\n      character = text.substr(i, j);\n      result.emoji = 1;\n      i += j - 1;\n    }\n\n    result.push(character === \">\" ? \"&gt;\" : character === \"<\" ? \"&lt;\" : character);\n  }\n\n  return result;\n}","/*!\n * TextPlugin 3.5.1\n * https://greensock.com\n *\n * @license Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nimport { emojiSafeSplit, getText, splitInnerHTML } from \"./utils/strings.js\";\n\nvar gsap,\n    _tempDiv,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n};\n\nexport var TextPlugin = {\n  version: \"3.5.1\",\n  name: \"text\",\n  init: function init(target, value, tween) {\n    var i = target.nodeName.toUpperCase(),\n        data = this,\n        _short,\n        text,\n        original,\n        j,\n        condensedText,\n        condensedOriginal,\n        aggregate,\n        s;\n\n    data.svg = target.getBBox && (i === \"TEXT\" || i === \"TSPAN\");\n\n    if (!(\"innerHTML\" in target) && !data.svg) {\n      return false;\n    }\n\n    data.target = target;\n\n    if (typeof value !== \"object\") {\n      value = {\n        value: value\n      };\n    }\n\n    if (!(\"value\" in value)) {\n      data.text = data.original = [\"\"];\n      return;\n    }\n\n    data.delimiter = value.delimiter || \"\";\n    original = splitInnerHTML(target, data.delimiter);\n\n    if (!_tempDiv) {\n      _tempDiv = document.createElement(\"div\");\n    }\n\n    _tempDiv.innerHTML = value.value;\n    text = splitInnerHTML(_tempDiv, data.delimiter);\n    data.from = tween._from;\n\n    if (data.from) {\n      i = original;\n      original = text;\n      text = i;\n    }\n\n    data.hasClass = !!(value.newClass || value.oldClass);\n    data.newClass = value.newClass;\n    data.oldClass = value.oldClass;\n    i = original.length - text.length;\n    _short = i < 0 ? original : text;\n    data.fillChar = value.fillChar || (value.padSpace ? \"&nbsp;\" : \"\");\n\n    if (i < 0) {\n      i = -i;\n    }\n\n    while (--i > -1) {\n      _short.push(data.fillChar);\n    }\n\n    if (value.type === \"diff\") {\n      j = 0;\n      condensedText = [];\n      condensedOriginal = [];\n      aggregate = \"\";\n\n      for (i = 0; i < text.length; i++) {\n        s = text[i];\n\n        if (s === original[i]) {\n          aggregate += s;\n        } else {\n          condensedText[j] = aggregate + s;\n          condensedOriginal[j++] = aggregate + original[i];\n          aggregate = \"\";\n        }\n      }\n\n      text = condensedText;\n      original = condensedOriginal;\n\n      if (aggregate) {\n        text.push(aggregate);\n        original.push(aggregate);\n      }\n    }\n\n    if (value.speed) {\n      tween.duration(Math.min(0.05 / value.speed * _short.length, value.maxDuration || 9999));\n    }\n\n    this.original = original;\n    this.text = text;\n\n    this._props.push(\"text\");\n  },\n  render: function render(ratio, data) {\n    if (ratio > 1) {\n      ratio = 1;\n    } else if (ratio < 0) {\n      ratio = 0;\n    }\n\n    if (data.from) {\n      ratio = 1 - ratio;\n    }\n\n    var text = data.text,\n        hasClass = data.hasClass,\n        newClass = data.newClass,\n        oldClass = data.oldClass,\n        delimiter = data.delimiter,\n        target = data.target,\n        fillChar = data.fillChar,\n        original = data.original,\n        l = text.length,\n        i = ratio * l + 0.5 | 0,\n        applyNew,\n        applyOld,\n        str;\n\n    if (hasClass) {\n      applyNew = newClass && i;\n      applyOld = oldClass && i !== l;\n      str = (applyNew ? \"<span class='\" + newClass + \"'>\" : \"\") + text.slice(0, i).join(delimiter) + (applyNew ? \"</span>\" : \"\") + (applyOld ? \"<span class='\" + oldClass + \"'>\" : \"\") + delimiter + original.slice(i).join(delimiter) + (applyOld ? \"</span>\" : \"\");\n    } else {\n      str = text.slice(0, i).join(delimiter) + delimiter + original.slice(i).join(delimiter);\n    }\n\n    if (data.svg) {\n      //SVG text elements don't have an \"innerHTML\" in Microsoft browsers.\n      target.textContent = str;\n    } else {\n      target.innerHTML = fillChar === \"&nbsp;\" && ~str.indexOf(\"  \") ? str.split(\"  \").join(\"&nbsp;&nbsp;\") : str;\n    }\n  }\n};\nTextPlugin.splitInnerHTML = splitInnerHTML;\nTextPlugin.emojiSafeSplit = emojiSafeSplit;\nTextPlugin.getText = getText;\n_getGSAP() && gsap.registerPlugin(TextPlugin);\nexport { TextPlugin as default };"],"sourceRoot":""}